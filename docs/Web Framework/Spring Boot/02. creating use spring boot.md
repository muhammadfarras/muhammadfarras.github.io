## Using `start.spring.io` to build apps
Banyak web stack diluarsana menggunakan banyak pustakan atau tools untuk membangun web application dan semuanya berisikan modul-modul yang saling berhubungan. Termasuk dengan Spring Boot, terdiri dari module-module.

Dahulu, sepelum lahirnya spring boot, setidaknya programmer dalam membangun sebuah web application melalui carai diantaranya, mencari sample maven di _stackoverflow_ atau beberapa blog yang menyediakan kumpulan modul yang sudah siap dipakai.

Namun setelah hadirnya spring boot, kita dapat memanfaatkan [start.spring.io](https://start.spring.io). Website tersebut dibuat dan dimaintain oleh **Spring Team**.

Sebelum membuat package, kita dapat memimilih opsi dibawah ini yang disediakan oleh start.spring.io
1. Kita dapat memilih versi dari Spring Boot
2. Dapat memimilih tool yang digunakan untuk membangun website, (_Gradle_ atau _Maven_)
3. Dapat memilih versi java (Minimum 17)
4. Dapat memilih module (Spring atau third party module lainnya) untuk digunakan pada project


!!! warning
    Saat memilih **Packaging**, Lebih baik memilih JAR files dari pada WAR files (mendurukung utnuk beberapa aplikasi server) sebagai _packaging mechanism_.


![Spring Initializr](aset/2.1 Spring-Initializr.png)

:   `Setidaknya untuk bagian ini, ikuti pilihan dibawah ini`

| Choose | Value |
| :----- | :----- | 
|Project | Maven|
| Langauge | Java|
| Spring Boot | 3.08|
| Project Metadata | Bebas, disesuaikan|
|Depedencies |Spring Web|

Setelah memilih field yang tersedia maka secara otomatis web akan mendownload compress file  dengan ekstensi rar. Selanjutnya uncompress file tersebut lalu buka folder menggunakan IDE yang digunakan.

## Creating a Spring MVC web controller
Setelah membuat folder project tersebut menggunakna IDE (saya menggunakan Intellij). InsyaAllah pada bagian ini kita akan membuat **web controller**.

Jadi apa itu web controller ? itu ada sebauh kumpulan kode yang dapat menerima HTTP _request_ dan memberikan respone. Biasanya, respone yang diberikan oleh web controller adalah HTML namun web controller juga dapat memberikan respone dalam bentuk JSON (Java Script Object Notation). HTTP request yang diterima oleh web controller dapat bervariasi, umumnya menggunakan GET atau POST.

Bagain dari Spring yang membuat kita dapat mambangu web controller adalah **Spring MVC (Movel View Control)**. Spring MVC adalah Module dari spring framework yang membuat kita dapat membangun sebuah aplikasi web diatas *servlet-based containers* menggunakan paradigma MVC.

Jika kita melihat file `pom.xml` yang berada pada root project. Pada bagian dependecies kita dapat melihat depedency Spring MVC

=== "pom.xml"

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    ```

Dependency diatas membuat kita dapat menggunaka anotasi yang disedian oleh Spring MVC dan komponen lainnya, serta membuat kita dapat mendefinisikan web controller. Untuk membuat web controller pertama, mari kita buat sebuah class dengan nama `HomeController`

!!! quote "Code"

    === "HomeController.java"

        ```java
        @Controller
        public class HomeController {

            /**
             * Anotasi untuk pemetaan HTTP GET alamat / untuk memanggil method ini
             * @return
             */
            @GetMapping("/")
            public String index(Model model){
                return "index";
            }
        }
        ```
Deskripsi kode diatas sebagai berikut
*  `@controller`: Anotasi Spring MVC untuk berkomunikasi ke Spring Boot bahwa class ini adalah web controller. Jadi, ketika aplikasi dijalankan, Spring Boot akan secara otomatis mendeteksi class ini melalau **component scanning** dan akan membuat instance class tersebut. (Makan kita tidak membuat instance dari class tersebut, karena hal itu sudah ditangani oleh Spring Boot)

*   `@GetMapping("/")`: Anotasi Spring MVC untuk pemetaan HTTP GET pada alamat root **/**. Jika client mengirim request alamat root, maka Spring Boot akan memanggil method dengan anotasi ini.

*   `index`: Karena kita menggunakan anotasi `@Controller`, maka return nilai `index` akan menjadi nama dari template yang akan dirender.

!!! info
    Nama dari class atau method tidak terlalu penting, namun anda harus memberikan dengan nama yang menggambarkan fungsi dari class dan method tersebut. Yang paling penting adalah anotasi @Controller dan @GetMappint yang mana memberikan sinyal bahwa class ini adalah web controller dan method yang dipanggil saat menerima request.

Kita seudah membaut sebuah web controller, namun ada yang terlewat, yaitu template. Dimana baru saja kita lihat pada catatan ini, method yang menggunakan @GetMapping mengembalikan nama dari template yang akan dirender. Pada bagian selanjutnya kita akan menambahkan module yang berguna untuk menrender template.

## Leveraging template to create content
Kita akan menggunakan module **mustache**. Saat awal membuat project di spring.initializr, kita dapat memilih mustache sebagai template engine.

![Mustache ](aset/2.2 Mustache.png)

Namun bagaimana jika kita sudah membuat web controller selama 3 bulan, dan apakah kita harus membuat project dari awal ?

Tentu tidak, kita dapat menambahkan module tersebut pada exisiting project dengan cara menambahkan depdency pada file `pom.xml` pada root folder.


=== "pom.xml"

    ```xml hl_lines="11-14"
    <?xml version="1.0" encoding="UTF-8"?>
        <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
            ...
            <dependencies>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>

                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-mustache</artifactId>
                </dependency>
            </dependencies>
            ...

        </project>
    ```

Jika module telah ada pada project kita, kita dapat langsung membaut sebuah template. 

Bawaanya, Spring Boot akan membaca semua template yang ada pada folder `src/resources/templates`. Setiap template engine[^1] memiliki _suffix_ masing-masing. Untuk template **mustace** akhirannya adalah `.mustahce`. Ketika method pada controller kita mengambilan nilai `index`, spring boot akan mentransform kedalam `src/resources/templates/index.mustache`, memgabil file tersebut dan mengirimnya ke Template Engine.

[^1]: Selain mustahce ada, Thymeleaf, Apache Freemaker dan Groovy Template.


Selanjutnya mari kita buat file `index.mustache` pada `src/resources/templates/`.

!!! quote "Code"

    === "inde.mustache"

        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
        </head>
        <body>
            <h3>Bismillah</h3>
            <p>
                Halo semuanya
            </p>
            </body>
        </html>
        ```

Selanjutnya kita jalankan aplikasi dan bukan alamat `localhost:8080`[^2] maka kita dapat melihat tampilan web sedeharna. Alhamdulillah sekarang kita telah membuat web controller dan template hamalam HTML.

[^2]: `localhost` adalah alamat mesin anda, bisa juga berisi nilai `127.0.0.1`. Sedangkan untuk `8080` adalah port bawaan yang digunakan oleh Tomcat. (Spring boot menggunakan server tomcat)

!!! info "Folder Contoh"
    Kode dapat dilihat pada module `bagian_2_awal`

### Adding demo data to a template
Applikasi web sesungguhnya menyediakan data. Data tersebut bisa bersumber dari DataBase, file pada server atau semisalnya. Untuk contoh kali ini, kita akan membuat demo data yang nantinya akan kita tampilkan pada template. Dibawah ini adalah update dari file `HomeController.java`

!!! quote "Code"

    === "HomeController.java"

        ```java
        @Controller
        public class HomeController {

            // #1
            record Video(String name){};
            
            // #2
            List<Video> videos = List.of(
            new Video("Film 1"),
            new Video("Film 2"),
            new Video("Film 3")
            );

            /**
             * Anotasi untuk pemetaan HTTP GET alamat / untuk memanggil method ini
             * @return
             */
            @GetMapping("/")
            public String index(Model model){ // #3
                // #4
                model.addAttribute("videos",this.videos);
                return "index";
            }
        }
        ```

Pada kode diatas kita menambah beberapa baris kode;

1. Kita membuat sebuah class baru dengan nama `Video`.
2. Kita men-declare dan initiate property `videos` untuk class HomeController.
3. Kita menambahkan parameter Model dari pada method dengan anotasi @GetMapping
4. Kita menambahkan attribute menggunakan method `#!java model.addAttribute` dan memberikan nama dengan nilai `videos` dan data dari property `#!java this.videos`.

!!! info
    Java 17 menyediakan beberapa fitur yang sangat memabtu kita dalam mengambangkan aplikasi menggunakan Spring Boot, diantaranya pada contoh diatas. Kita dapat membuat sebuah Object Video hanya dengan satu baris kode menggunakan statement **record**


!!! tip
    Mengapa kita harus membuat `record` untuk meng-enkasulapso data dengan elemen tunggal ? Mustache beroperasi menggunakan attribute yang bernama. Kita dapat secara manual membuat JSON yang berisikan _name_ dan _value_, namuna dengan adanya Java 17 kita dapat langsung dengan mudah menggunakan `record`. Ditambah, fitur tersebut memberikan type safety.

Untuk mengirim data ke template, kita membutuhkan objek yang dipahami oleh Spring MVC. Kita butuh holder untuk menyimpan data. Untuk itu, kita membutuhkan parameter `Model` pada method index. 

Spring MVC memiliki attribute opsional yang dapat kita gunakan untuk web method apapun, pada kasusu kali ini, `Model` adalah yang diguakan jika kita ingin mengirim data ke template enggine.

Pada `HomeController.java` kita telah membuat data dummpy `#!java List<Video>.` dan mengirimkan menggunakan method attribute yang diberi nama **videos**. Dengan demikian kita dapat membuat kode kita dibawah ini agar dapat menampilkan data tersebut.

!!! quote "Code"

    === "index.mustache"

        ```html hl_lines="4-8"
        <!DOCTYPE html>
        <html lang="en">
        ... <!-- dipersingkat -->
        <ul>
            {{#videos}}
                <li>{{name}}</li>
            {{/videos}}
        </ul>
        </body>
        </html>
        ```
Penjelas kode yang di- _highlight_ diatas sebagai berikut;

*   `{{#videos}}`: **Directive** untuk mengambil attribute `videos` yang kita berikan pada object `#!java Model`. Karena yang kita berikan dalam bentuk data list maka mustache memperlebar sebanyak data yang ada pada list. _It will iterate over each entry of the `#!java List<Video>` collection stored in Model and create a separate HTML `#!html <li>` entry._

*   `{{name}}`: _Indicates we want the name field of the data construct. This lines up with our Video type’s name field. In other words, for each entry of `#!java List<Video>`, print out the name field between `#!html <li>` and `#!html </li>`._

*   `{{/videos}}`: _Indicates the end of the looping fragment._

!!! info "Folder Contoh"
    Kode dapat dilihat pada module `bagian_2`


### Building our app with a better design
Aplikasi terakhir yang kita buat masih sederhana. Secara gamblang kita membuat data model dan menyediakannya untuk ditampilkan pada template.

Namun terdapat masalah kedepannya, dimana design kode kita tidak dapat digunakan kembali (not reusable). Maka dari itu kita butuh controller kedua dimana ada beberapa alasan mengapa kita melakukan itu;

1.  Controller seharusnya tidak mengurusi definisi data. Karena tugas mereka hanyalah memberikan respone atas request lalau berinteraksi dengan service lain atau sistem, definisi ni harus berada pada tingkat bawah.

2.  Web controller yang menangani beban yang banyak (_serving data, manage data, calculate data, etc_) akan membuat kita kesuliat saat ada penyesuaian pada web. Maka dari itu, sangat disaranakan jika managemen data ditaruh pada tingkat yang lebih bawah.

Maka dari itu, kita akan memindahkan class `Video` ke file tersendiri, `Video.java`.


!!! quote "Code"

    === "Video.java"

        ```java
        record Video (String name) { }
        ```

Selanjutnya, kita akan memisahkan datar objek Videos kedalam service yang terpisah. Kita akan membuat class baru dengan nama VideoService dengan isi sebagai berikut;

!!! quote "Code"

    === "VideoService.java"

        ```java
        @Service
        public class VideoService{
            private List<Video> videos = List.of(
                    new Video("Film 1"),
                    new Video("Film 2"),
                    new Video("Film 3")
            );

            public List<Video> getVideos(){
                return this.videos;
            }
        };
        ```
`@Service`: Anotasi yang menunjukan sebuah class yang harus diambil saat _component scanning_ dan ditambahkan pada _application context_.

Selanjuta kita akan memodifikasi kode dari `HomeController` menjadi sebagai berikut;

!!! quote "Code"

    === "HomeController.java"

        ```java
        @Controller
        public class HomeController {
            private VideoService videoService;

            public HomeController(VideoService videoService){
                this.videoService = videoService; // Inject VideoService.
            };

            ... // Cut
        }
        ```

#### Injecting dependencies through constructor calls
Constructor injectiong adalah yang paling disukai oleh programmer untuk memberikan dependecies yang Spring bean butuhkan melalui constructor. Untuk itu, setiap kita membuat Java class yang diambil oleh Spring Boot sata componet scanning. Spring Boot secara ototmatis akan melihat apakah ada injection points, dan jika ada, maka Spring Boot akan melihat apllication contextnyam dan menginject-nya. Metode tersebut disebut dengan **Autowiring**. Kita membiarkan Spring yang menangani pencarian dependencies dari Spring pada application context serta memasang depedencies tersebut.

Karena kita sudah meng-inject `VideoServive` kedalam `HomeController`, kita dapat mengupdate method `#!java index()` sebagai berikut;

!!! quote "Code"

    === "HomeController.java"

        ```java
        ...
        @GetMapping("/")
        public String index(Model model){
            model.addAttribute("videos", videoService.getVideos());
            return "index";
        }
        ```

!!! info "Folder Contoh"
    Kode dapat dilihat pada module `bagian_2_2`


### Changing the data through HTML forms
Pada bagian kali ini kita akan membuat sebuah web yang dapat menerima data dan menampung daata tersebut di `#!java List<String>`. Pertama kita harus membuat perubaha pada `index.mustache` agar bisa menerima input dari user.

!!! quote "Code"

    === "index.mustache"

        ```html
        ...
        <form action="/new-video" method="post">
            <input type="text" name="name">
            <button type="submit">Submit</button>
        </form>
        ```

Jika kita melihat kode diatas, pada nilai di attribute _action_ dan _method_ artinya setelah user mengisi nilai masukan, user akan membuat request ke `HTTP POST /new-video`. Maka dari itu kita harus membuat mapping untuk memberikan respone atas request tersebut. Dibawah ini adalah update dari `HomeController.java`;

!!! quote "Code"

    === "HomeController.java"

        ```java hl_lines="14-18"
        @Controller
        public class HomeController {
            private VideoService videoService;

            public HomeController(VideoService videoService){
                this.videoService = videoService;
            };
            @GetMapping("/")
            public String index(Model model){
                model.addAttribute("videos", videoService.getVideos());
                return "index";
            }

            @PostMapping("/new-video")
            public String addVideo(@ModelAttribute Video newVideo){
                this.videoService.create(newVideo);
                return "redirect:/";
            }
        }
        ```
Dibawah ini adalah penjelasan dari kode yang kita highlight

*   `@PostMapping("/new-video")`: Anotasi untuk menerima POST /new-video dan mengarahakannya ke method ini.
*   `@ModelAttributes Video newVideo`: Anotas untuk mem-parse, mengurai incoming HTML form kedalam Video Object
*   `videoService.create()`: Method yang akan kita buat setelah ini, fungsi ini untuk menambahkan nilai masukan ke `#!java List<String>`
*   `"redirect:/"`: Spring MVC directive yang mengirim ke browser HTTP 302 Found to URL */*. 302 redirect adalah standar yang digunakan untuk merujuk kembali ke url tertentu.

Sekarang kita harus membuat method dengan nama `#!java videoService.create(Video newVideo)`. Namun ada yang perlu diperhatika, kita menggunakan `#!java List.of()` untuk membuat kumpulan video, yang mana menghasilkan **immutable lists**.Namun, karena Immutable list implement java List interface, yang mana memberikan kita akses method `#!java add()`. Namun jita kita menggunakan method tersebut, akan memunculkan exception `#!java UnsupportedOperationException`.

!!! quote "Code"

    === "Example.java"

        ```java hl_lines="14-18"
        @Service
        public class VideoService{

            private List<Video> videos = List.of(
                    new Video("Film 1"),
                    new Video("Film 2"),
                    new Video("Film 3")
            );

            public List<Video> getVideos(){
                return this.videos;
            }

            public void create(Video addedVideo){
                ArrayList<Video> extend = new ArrayList<Video>(this.videos);
                extend.add(addedVideo);
                this.videos = List.copyOf(extend);
            }
        };
        ```

Holla, sekarang kita bisa mengirim data pada form.

!!! info "Folder Contoh"
    Kode dapat dilihat pada module `bagian_2_3`

## Creating JSON-based APIs
Salah satu yang memubat Spring Boot powerfull adalah, ketika kita menambahkan Spring web kesebuah project, module tersebut sekaligus menambahkan **Jackson** ke classpath. Jackson adalah pustaka untuk Serialization/Deserialization JSON ke Java Object atau sebaliknya.

Kali ini, isnyaAllah kita akan membuat REST API. Maka dari itu, kita harus membuat sebuah class baru pada package yang sama. Kita akan membuat class dengan nama `ApiController` dan diberi anotasi @RestController.

@RestController mirip dengan @Controller. Itu adalah anotasi yang memberikan sinyak ke Spring Boot bahwa class ini secara otomatis harus diambil saat component scanning dan dijadikan sebuah Spring bean. Bean ini akan didaftarkan pada application context dan juga dengan Spring MVC sebagai conroller class sehingga dapat merujuk ke web calls.

Namun ada tambahan property, anotasi tersebut merubah semua method dari _template-based_ ke _JSON-based_. Dalam kata lain, dari pada web method mengembalikkan nama dari template yang Spring MVC render melalaui template engine, anotasi tersebut akan mengembalikan serialize data menggunakan Jackson.

!!! quote "Code"

    === "APIVideos.java"

        ```java
        @RestController
        public class APIVideos {
            private VideoService videosService;

            public APIVideos(VideoService videos){
                this.videosService = videos;
            }

            @GetMapping("/API/videos")
            public List<Video> getAll(){
                return this.videosService.getVideos(); //#(1)!
            }
        }
        ```
        
        1.  Akan dirender otomatis dari `#!java List<Video>` kedalam JSON oleh Jackson

Method diatas akan mengambil list dari vide dan mengembalikan list tersebut, yang menyebabkan list tersebut dirender kedalam bentuk JSON Array oleh Jackson.

Sekarang coba kita gunakan [postman]() untuk mengirim request, maka hasil yang didapatkan sebagai berikut;

```json
[
    {
        "name": "Film 1"
    },
    {
        "name": "Film 2"
    },
    {
        "name": "Film 3"
    }
]
```

API yang hanya menghasilkan JSON tidak dikatan API yang sesungguhnya, API tersebut juga harus menerima nilai masukan dan melakukan sesuatu dibelakangnya dan memberikan respone balikan juga dalam bentuk JSON. Untuk itu kita harus membuat HTTP Post call pada class yang sama, `ApiController`.

Sekarang kita tambahkan method `#!java addVideo()` pada class `APIVideos`

!!! quote "Code"

    === "APIVideos.java"

        ```java hl_lines="14-17"
        @RestController
        public class APIVideos {
            private VideoService videosService;

            public APIVideos(VideoService videos){
                this.videosService = videos;
            }

            @GetMapping("/API/videos")
            public List<Video> getAll(){
                return this.videosService.getVideos();
            }

            @PostMapping(value = "/API/videos", consumes = {"*/*"})
            public Video addVideo (@RequestBody Video addVideo){
                return this.videosService.create(addVideo);
            }
        }
        ```



@PostMapping: Maps HTTP POST calls to /api/videos onto this method
• @RequestBody: Spring MVC’s annotation to signal that the incoming HTTP request body
should be deserialized via Jackson into the newVideo argument as a Video record
• We then delegate the actual handling of this incoming Video record to our VideoService,
returning back the record after it’s been added to the system

---

sample

!!! quote "Code"

    === "Example.java"

        ```java

        ```

        ```{.java title="Output"}
        
        ```

!!! quote "Code"

    === "Example.java"

        ```java

        ```

        ```{.java title="Output"}
        ```

    === "Example.java"

        ```java

        ```

        ```{.java title="Output"}

        ```

!!! quote "Code"

    ```java title=""

    ```

    === "Example 1"

        ```java

        ```

        ```{.java title="Output"}

        ```

    === "Example 2"

        ```java

        ```

        ```{.java title="Output"}

        ```