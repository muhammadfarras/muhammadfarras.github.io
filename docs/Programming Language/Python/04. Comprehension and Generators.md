# Comprehensions and Generators

Pada bagian ini saya menuliskan catatan yang bertujuan bukan semata untuk meningkat performa dari kode yang dibuat namun juga tetap mempertahankan kode yang mudah untuk dibaca dan mudah untuk di maintain. Sehingga catatan ini secar umum membahas

*   Fungsi `#!python map()`, `#!python zip()`, dan `#!python filter()`
*   Comprehensions
*   Generators

InsyaAllahk kita akan melakukan beberapa perhitungan dan perbandingan terhadap beberapa kode yang dicatat dan membuat kesimpulan dari perhitungan dan perbandingan tersebut, terutama pada waktu yang dibutuhkan mesin untuk menajalankan kode.

Coba perhatikan kode dibawah ini. Kedua fungsi ini mengembalikan akar kuadrat dari parameter yang diberikan.

!!! quote "Code"

    === "Fungsi Square Satu"

        ``` {.python}
        %%timeit
        def square_satu(n):
            return n**2

        square_satu(10)
        ```

        ```{.python .no-copy}
        338 ns ± 14.8 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)
        ```



    === "Fungsi Square Dua"

        ``` {.python}
        %%timeit
        def square_dua(n):
            return n*n

        square_satu(10)
        ```

        ```{.python .no-copy}
        127 ns ± 1.06 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)

        ```

Fungsi diatas sama-sama mengembalikan nilai akar pangkat dari parameter yang diberikan. Sekilas fungsi `#!python square_dua()` lebih cepat. Namun kebanyakan kita tidak terlalu memikirkan performa yang sedikit berbeda. Dalam kasus diatas tidak masalah jika mengutaman demikian, lagi pula fungsi `#!python square_satu()` lebih mudah dibaca. Jadi kapan sebuah performa menjadi isu yang diutamakan ? {==Yaitu ketika kita berhubungan dengan data yang amat besar ==}.

Misalkan kita menggunakan kedua fungsi diatas ke data yang memliki 10 juta baris. Jika perbedaan dari fungsi tersebut misalkan `0.1` detik. Sehingga jika diaplikasikan ke data tersebut maka akan memliki rentang waktu 27 jam, Cukup signifikan, dan disinilah kita harus mempertimbangkan masalah performa.

Jadi dibawah ini saya mencatat eksplorasi tentang [iterators](02. Conditional and Iteration/#iterators-and-iterable) yang menghemat penyimpanan dalam menjalankan operasi sederhana dari sebuah kumpulan data secara sekaligus.


## Fungsi `#!python map`, `#!python zip`, dan `#!python filter`
Dibawah ini saya mencatat cara menggunakan fungsi map, zip dan filter serta bagaimana cara menggunakan generators dan comprehension untuk menghasilkan nilai yang sama menggunakan ketiga fungsi diatas.

### Map
Arti map dari dokumentasi resmi python.

!!! describe "Apa itu Map"
    `#!python map(function, iterable, …)`

    _Return an iterator that applies function to every item of iterable, yielding the results.
    If additional iterable arguments are passed, function must take that many arguments
    and is applied to the items from all iterables in parallel. With multiple iterables, the
    iterator stops when the shortest iterable is exhausted._

{==
InsyaAllah kita akan bahas tentang `yield` pada bagian catatan dibawah ini.
==}

Bahasa catatan saya, fungsi map ini memiliki parameter 2 parameter wajib dan opsinal. Dimana fungsi ini akan mengembalikan nilai dalam bentuk iterator hasil dari operasional fungsi pada parameter pertama atas iterable. Jika parameter diisi lebih dari satubuah iterbale maka fungsi ini akan sekelsai beroperasi hingga iterable terpendek habis nilainya. Dibawah ini penejelasan tentang parameter tersebut

1.  **function**, parameter wajib ini diisi dengan sebuah fungsi atau lambda yang menerima nilai dari parameger iterable.
2.  **iterable**, parameter wajib ini diisi dengan iterable, bisa berupa list, tuple, set atau dict.
3.  **iterable***, paremeter opsional ini diisi dengan iterble. {==Bisa lebih dari satu buah parametel opsional==}.

Mari coba implementasi pada sebuah studi kasus. Katakan ada data nilai mahasiswa dalam bentuk dicitonary dibawah ini. kita diarahkan untuk mengurutkan nilai mahasiswa berdasarkannilai rata-rata.

```python title="Data"
students = [
dict(id=0, credits=dict(math=9, physics=6, history=7)),
dict(id=1, credits=dict(math=6, physics=7, latin=10)),
dict(id=2, credits=dict(history=8, physics=9, chemistry=10)),
dict(id=3, credits=dict(math=5, physics=5, geography=7)),
]
```

!!! quote "Code"

    ``` {.python}
    rata_rata = sorted(map(lambda n: (sum(n["credits"].values()),n), students), reverse=True)
    mengeluarkan_nilai = map(lambda n: n[1], rata_rata)

    for a in mengeluarkan_nilai:
        print(a)
    ```

    ```{.python .no-copy}
    {'id': 2, 'credits': {'history': 8, 'physics': 9, 'chemistry': 10}}
    {'id': 1, 'credits': {'math': 6, 'physics': 7, 'latin': 10}}
    {'id': 0, 'credits': {'math': 9, 'physics': 6, 'history': 7}}
    {'id': 3, 'credits': {'math': 5, 'physics': 5, 'geography': 7}}
    ```

### Zip
Berdasarkan dokumentasi resmi python, zip adalah

!!! describe "Apa itu Map"
    `#!python zip(*iterables)`

    _Returns an iterator of tuples, where the i-th tuple contains the i-th element from
    each of the argument sequences or iterables. The iterator stops when the shortest
    input iterable is exhausted. With a single iterable argument, it returns an iterator
    of 1-tuples. With no arguments, it returns an empty iterator._

Fungsi `#!python zip()` mengembalikan sebuah iterator yang berisi tuple dari setiap nilai iterable yang pada parameter. Jika iterable pada parameter-parameter yang diberikam terpendek telah habis maka operasi akan berhenti.

Dibawah ini kode yang semoga membuat anda paham tentang fungsi ini.

!!! quote "Code"

    ``` {.python}
    angka_1 = [1,2,3,4,5,6]
    angka_2 = [6,5,4,3,2,1]

    gabungan = zip(*(angka_1,angka_2))

    for a,b in gabungan:
        print(a,b,sep="|")
    ```

    ```{.python .no-copy}
    1|6
    2|5
    3|4
    4|3
    5|2
    6|1
    ```

Untuk memahami lebih dalam tentang fungsi yang telah dicatat diatas `#!python map` dan `#!python zip` coba selesaikan tugas dibawah ini.

!!! question "Tugas"
    Anda memliki nilai dibawah ini, buatlah sebuah logika menggunakan fungsi map dan zip untuk mengembalikan nilai tertinggi dari ketiga iterable ini pada setiap data. dibawahi ini adalah data yang diberikan

    ```python
    a = [5, 9, 2, 4, 7]
    b = [3, 7, 1, 9, 2]
    c = [6, 8, 0, 5, 3]
    ```

    ??? note "Jawaban"
        ``` {.python}
        hasil_max = list(map(lambda n : max(n), zip(a,b,c)))
        print(hasil_max)
        ```

        ```{.python .no-copy}
        [6, 9, 2, 9, 7]
        ```

### filter
Oke, semua bersumber dari dokumentasi resmi. Sebagaimana islam bersumber dari _Al-Quran_ dan _As Sunnah_ sesuai dengan pemahaman para sahabat :fontawesome-solid-people-group:.

!!! describe "Apa itu Map"
    `#!python filter(function, iterable)`

    _Construct an iterator from those elements of iterable for which function returns
    True. iterable may be either a sequence, a container which supports iteration, or an
    iterator. If function is None, the identity function is assumed, that is, all elements
    of iterable that are false are removed._

Fungsi `#!python filter` membuat sebuah interator dari elemen-elemen parameter iterable yang hanya bernilai `#!python True` setelah dilakukan operasi pada sebuah fungsi atau lambda.

Katakan anda anda diberikan sekumpulan nilai _student_ seperti contoh [map](#map) diatas. Anda diperintahkan mengambil data hanya nilai yang melebihi nilai kkm sebesar 6.

!!! quote "Code"

    ``` {.python}
    students = [
    dict(id=0, credits=dict(math=9, physics=6, history=7)),
    dict(id=1, credits=dict(math=6, physics=7, latin=10)),
    dict(id=2, credits=dict(history=8, physics=9, chemistry=10)),
    dict(id=3, credits=dict(math=5, physics=5, geography=7)),
    ]

    nilai_lulus = list(filter(lambda n : min(n["credits"].values()) >= 6, students))
    nilai_lulus
    ```

    ```{.python .no-copy}
    [{'id': 0, 'credits': {'math': 9, 'physics': 6, 'history': 7}},
    {'id': 1, 'credits': {'math': 6, 'physics': 7, 'latin': 10}},
    {'id': 2, 'credits': {'history': 8, 'physics': 9, 'chemistry': 10}}]
    ```

## Comprehensions
Comprehension adalah notasi ringkas untuk melakukan beberapa operasi pada setiap elemen dari objek (iterable atau memeliki turunan iterator) dan atau hanya mengambil subset dari element pada obejek (seperti filter) yang sesui dengan kondisi tertentu.

Python memliki bebera tipe comprehension, seperti _list comprehension_, _dictionary comprehensions_, dan _set comprehensions_. Namun pada catatan ini saya hanya mencatat _list comprehension_. Karena dari bukuknya juga mencatumkan itu saja. Akan tetapi sytanxnya sama hanya membedakan beberapa karakter saja.

```{.python .no-copy title="Sytanx list comprehensions"}
[result_value for a in squance_objects conditional_logic]
```

Dibawah ini cara membuat sebuah list yang berisikan kuadrat dari nilai yang diberikan. Saya akan membuat nya dengan 3 cara. pertama menggunakan perulangan, kedua memanfaat fungsi `#!python map` dan ketiga menggunakan _list comprehension_.


!!! quote "Code"
    === "For loop"

        ``` {.python}
        nilai_kuadrat = []

        for a in range(10):
            nilai_kuadrat.append(a ** 2)
            
        print (nilai_kuadrat)
        ```

        ```{.python .no-copy title="Print Output"}
        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
        ```

        Kata penulis buku ini, "_If you code like this, you are not python dev_" :fontawesome-solid-face-laugh-squint:

    === "Menggunakan `#!python map()`"

        ``` {.python}
        nilai_kuadrat = list(map(lambda n : n**2, range(10)))
        print(nilai_kuadrat)
        ```

        ```{.python .no-copy title="Print Output"}
        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
        ```

    === "Menggunakan _list comprehensions_"

        ``` {.python}
        [a**2 for a in range(10)]
        ```

        ```{.python .no-copy title="Print Output"}
        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
        ```

MasyAllah, penggunaan comprehension list sangat pendek untuk menghasilkan nilai yang sama. Sekarang mari kita coba untuk menambahkan penyaringan hanya untuk nilai yang genap dengan cara-cara diatas. Cara pertama kita akan menambahkan _if conditionl_ dan pada cara kedua menggunakan fungsi `#!python filter()`. Lalu bagaimana dengan cara yang menggunakan comprehension ? Oke lihat catatan kode dibawah ini.

!!! quote "Code"
    === "For loop"

        ``` {.python}
        nilai_kuadrat = []

        for a in range(10):
            if not (genap:= (a**2)) % 2: # (1)!
                nilai_kuadrat.append(genap)
            
        print (nilai_kuadrat)
        ```

        1.  `#!python not (genap:= (a**2)) % 2` ekuivalen dengan `#!python (genap:= (a**2)) % 2 == 0:`

        ```{.python .no-copy title="Print Output"}
        [0, 4, 16, 36, 64]
        ```

        Kode diatas memanfaatkan [walrus operator](02. Conditional and Iteration/#walrus-operator)

    === "Menggunakan `#!python map()`"

        ``` {.python}
        nilai_kuadrat = list(filter(lambda a : not (a % 2),map(lambda n : n**2, range(10)))) # (1)!
        print(nilai_kuadrat)
        ```

        1.  `#!python  not (a % 2)` ekuivalen dengan `#!python a %2  == 0`

        ```{.python .no-copy title="Print Output"}
        [0, 4, 16, 36, 64]
        ```

    === "Menggunakan _list comprehensions_"

        ``` {.python}
        [a**2 for a in range(10) if not (a**2) % 2] # (1)!
        ```

        1.  `#!python not (a**2) % 2` ekuivalen dengan `#!python (a**2) % 2 == 0`

        ```{.python .no-copy title="Print Output"}
        [0, 4, 16, 36, 64]
        ```


### Nested comprehensions
Kode dibawah ini adalah kode yang menggunakan nested for loop

!!! quote "Code"

    ``` {.python}
    kata = 'abcd'
    hasil = []
    for a,b in enumerate(kata):
        for c in kata[a:]:
            hasil.append((b,c))
            
    print(hasil)  
    ```

    ```{.python .no-copy title="Print Output"}
    [('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'b'), ('b', 'c'), ('b', 'd'), ('c', 'c'), ('c', 'd'), ('d', 'd')]
    ```

Kode diatas juga bisa dibuat menggunakan **nested list comprehensions**.

!!! quote "Code"

    ``` {.python}
    kata = 'abcd'
    [(b,c) for a,b in enumerate(kata) for c in kata[a:]] 
    ```

    ```{.python .no-copy title="Print Output"}
    [('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'b'), ('b', 'c'), ('b', 'd'), ('c', 'c'), ('c', 'd'), ('d', 'd')]
    ```

!!! info
    Infat, string juga termasuk squance didalam python

### Filtering comprehensions
Sebelumnya kita telah menggunakan fungsi filtering pada comprehensions. Pada catatan ini saya hanya menuliskan kembali sebuah kode yang lebih kompleks untuk menghitung pytagoras serta hanya mengembalikan nilai _rill_ (bilangan bulat) atas operasi tersebut.

=== "Menggunakan Comprehension List"

    !!! quote "Code"

        ``` {.python}
        mx = 10
        [ (a,b,int(c)) 
        for a in range(1,mx) 
        for b in range (a,mx) 
        if (c:=sqrt(a**2 + b**2)).is_integer()]
        ```

        ```{.python .no-copy title="Print Output"}
        [(3, 4, 5), (6, 8, 10)]
        ```

=== "Menggunakan for loop"

    !!! quote "Code"

        ``` {.python}
        # Using for loop
        from math import sqrt
        mx = 10
        real_pytha = []

        for a in range (1,mx):
            for b in range(a,mx):
                if (hasil:= sqrt(a**2 + b**2)).is_integer():
                    real_pytha.append([a,b,int(hasil)])

        real_pytha
        ```

        ```{.python .no-copy title="Print Output"}
        [(3, 4, 5), (6, 8, 10)]
        ```

### Dictionary Comprehensions
Sama halnya dengan list comprehensions, dictionary comprehensions hanya berbeda hasil dari comprehensions nya, yaitu menghasilkan dictionary.

!!! quote "Code"

    ``` {.python}
    from string import ascii_letters # (1)!
    {urut:huruf for urut, huruf in enumerate(ascii_letters[10:20])} # (2)!
    ```

    1.  name `ascii_letters` berisikan string huruf kecil dan kapital
    2.  Hanya mengambil kata dari 10 - 20, untuk meringkas hasil output

    ```{.python .no-copy title="Print Output"}
    {0: 'k',1: 'l',2: 'm',3: 'n',4: 'o',8: 's',9: 't'}
    ```

Dan, dictionary tidak bisa menampung *key* yang ganda

!!! quote "Code"

    ``` {.python}
    sapa = 'hello farras'
    {huruf:urut for urut, huruf in enumerate(sapa)}
    ```

    ```{.python .no-copy title="Print Output"}
    {'h': 0, 'e': 1, 'l': 3, 'o': 4, ' ': 5, 'f': 6, 'a': 10, 'r': 9, 's': 11}
    ```

### Set Comprehensions


