---
search:
  boost: 0.5
---

# Using the shell command

## Menggunakan Virtual Console
Kebanyakan Linux system yang memliki dekstop interface memulai beberapa virtual console yang berjalan pada komputer. Virtual consol adalah cara untuk memliki beberapa shell session yang dibuka berbarengan dengan grafik interface yang digunakan. Artinya, virtual console ini berjalan berbarengan dengan dibukanya grafik interface saat menjalankan linux

Kita dapat mengganti antara virtual console dengan mekenan ++ctrl++ dan ++alt++ dan menekang function key antara ++f3++ dan ++f6++. Sedangkan untuk ++f1++ dan ++f2++ akan membuat anda kembali kedalam GUI session. 

``` { .yaml .no-copy }
# ctr + alt + f3
Ubuntu 21.10 BrownTofu tty3
BrownTofu Login:

# ctr + alt + f4
Ubuntu 21.10 BrownTofu tty4
BrownTofu Login:

# ctr + alt + f5
Ubuntu 21.10 BrownTofu tty5
BrownTofu Login:
```

## Choosing Your Shell
Pada umumnya, shell bawaan yang ada pada linux adalah Bash Shell. Untuk mengetahuinya, gunakan perintah dibawah ini
``` shell
$ grep $(whoami) /etc/passwd 
# Output (1)
```

1.  maruffarras:x:1000:1000:maruffarras,,,:/home/maruffarras:/bin/bash

Perintah `whoami` berfungsi untuk menampilakan username. Hasil dari perintah tersebut digunakan untuk parameter perintah `grep`, yang mana berfungsi untuk mencari pola pada parameter yang tersedia pada sebuah file. Pada bagian akhir dari gabunga commad tersebut menunjukan Bash shell adalah shell bawaan anda.

Memungkinkan, namun sangat jarang, anda mungkin memliki shell bawaan yang berbeda (bukan Bash). Untuk mencoba shell yang berbeda, mudahnya ketik nama dari shell tersebut pada terminal (seperti dash, atau yang lainnya, dengan asumsi sudah terinstall).

```{.shell .no-copy } 
maruffarras@BrownTofu:~$ dash
$ echo "This is dash shell"
# Output (1) 
```

1.  This is dash shell

Meskipun kebanyakan pengguna linux lebih condong ke satu shell saja, jika anda sudah paham satu shell, anda dapat dengan cepat mempelajara shell lainnya dengan sesekali merujuk ke *shell's man page*. Perintah `man` menyediakan dokumentasi dari sebuah commands (perintah), file formats, dan komponen lainnya pada linux.

``` {.shell .no-copy}
maruffarras@BrownTofu:~$ man nmap
# Output (1)
```

1.  NMAP(1)  Nmap Reference Guide  NMAP(1)
NAME
nmap - Network exploration tool and security / port scanner


Bash memliki fitur asli yang dikembangkan awalnya untuk shell *sh* dan *ksh* pada awal UNIX systems, sebagaimana fitur-fitur pada *csh*, harapannya Bash menjadi login shell bawaan pada banyak Linux Systems, terkecuali beberapa Linux System tertentu (seperti shell yang berjalan pada perangkat yang tertanam, *emebedded system*) yang tidak memakan memori besar dan tidak perlu terlalu banyak fitur.

### `id` and `who` Command
Ketika anda login kedalam linux, linux membaca informasi identitas anda seperti username, group name, user ID dan Group ID (look at id command).

``` {.shell .no-copy}
maruffarras@BrownTofu:~$ id
```

!!! Abstract "Output"

    ``` {.shell .no-copy}
    uid=1000(maruffarras) gid=1000(maruffarras) groups=1000(maruffarras),4(adm),20(dialout),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),133(lxd),134(sambashare)
    ```

Berdasarkan hasil perintah `id` diatas, *username* adalah maruffarras, yang mana direpresentasikan dengan ID numerik `(uid) 1000`   
Group pertama user maruffarras juga memliki nama `maruffarras` yang mana memiliki `gid 1000`. Umum terjadi di Ubuntu jika group user memliki nama yang sama dengan user. User maruffarras juga memiliki group lain, `4(adm)`, `20 (dialout)` dst. Angka tersebut merepresentasikan hak akses (*permission*) yang dimiliki maruffarras pada sistem.

Linux juga selalu melacak session login anda, linux mengetahui ketika anda masuk dan berapa lama session tersebut digunakan, serta dari mana anda masuk kedalam sistem linux (*tty*). Gunakan perintah `who -uH` untuk melihat login session user anda yang sedang berlangsung.

``` shell
who -uH
```

!!! Abstract "Output"

    ``` {.shell .no-copy}
    maruffarras@BrownTofu:~$ who -uH

    NAME        LINE         TIME             IDLE          PID COMMENT
    maruffarras tty2         2022-11-28 21:16 00:16        2055 (tty2)
    maruffarras tty4         2022-11-28 21:30   .          4510
    ```

Informasi yang diberikan oleh perintah `who` bahwa user maruffarras telah masuk/login pada tty2 dan tty4, session login tersebut dimulai dari 2022-11-28 21:16. **IDLE** menunjukan berapa lama shell terbuka. *PID* menunjukan process ID dari login sell user.

### Locating Commands
Dalam menjalankan sebuah perintah yang kita ketik, shell akan merujuk pada sebuah daftar yang kita ketahui sebagai alamat `$PATH`. Namun anda juga dapat menuliskan langsung alamat lengkap dari command yang ingin dijalankan, dengan cara ini berarti anda tidak menggunakan pintasan yang disediakan oleh `$PATH`. Contoh penulisan alamant lengkap, misalkan command *date* berada pada lokasi **/bin**, anda dapat mengetik *date* langsung, atau dilengkapi dengan alamat, menjadi `/bin/date`.

Dalam mencari command yang diperintahkan, shell akan merujuk pada $PATH anda. Namuun untuk command yang tidak ada dalam variabel $PATH, anda dapat menulis dengan lengkap lokasi dari command tersebut. Misalkan, command date berada pada lokasi /bin, anda dapat mengetik date ataupun dilengkapi dengan alamat dari command date.

``` {.shell .no-copy}
maruffarras@BrownTofu:~$ /bin/date 
# Output (1)
```

1.  Sen 28 Nov 2022 09:39:37  WIB

Namun, cara tersebut sangat tidak efesien, apalagi jika alamat dari command tersebut sangat panjang. Cara yang terbaik adalah menyimpan alamat lengkap dari perintah tersebut pada variabel $PATH environment variable. Anda dapat memanggil command *date* menggunakan tanpa menggunakan alamat lengkap asalakan direktori command tersebut berada di varaibel $PATH.

``` {.shell .no-copy}
maruffarras@BrownTofu:~$ date 
# Output (1)
```

1.  Sen 28 Nov 2022 09:39:37  WIB

$PATH terdiri dari daftar direktori yang akan dilihat oleh shell ketika kita memulai untuk menjalan command.

``` {.shell .no-copy}
echo $PATH
# Output (1)
```

1.  /home/maruffarras/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
:/usr/games:/usr/local/games

Daftar direktori-direktori dipisahkan menggunakan colon :, Hampir semua command dari linux tersimpan di `/bin`, `/usr/bin` atau `/usr/local/bin`. Command yang berhubungan tugas dengan administrasi terkumpul pada direktori `/sbin` dan `/usr/sbin`.

!!! note
    Linux mencari command *date* tanpa penulisan alamat lengkapnya di daftar direktori yang ada pada variabel **$PATH**. Perhatikan ada alamat `/bin` didalamnya.


Jika anda ingin membuat sebuah command untuk user maruffarras, anda harus memasukan script didalam direktori `/home/maruffarras/.local/bin`, jika command tersebut ingin diakses oleh semua user anda dapat menaruhnya di `/usr/local/bin`.

Urutan alamat direktori pada $PATH dibaca dari kiri ke kanan (left → right), jadi jika terdapat commad dengan nama *foo* berlokasi di `/usr/bin` dan `/bin`, maka command yang akan dieksekusi adalah *foo* yang berada dalam direktori `/usr/bin`. Jika anda ingin mengeksekusi command ditempat tertentu anda harus menggunakan alamat yang lengkap atau mengubah urutan dari $PATH.

Tidak semua command ditempatkan pada direktori yang ada pada variable **$PATH**. ==Beberapa command tertanam didalam shell==. Perintah juga dapat ditiban dengan membuat **aliases** yang dapat mendefinisikan command serta opsi-opsinya yang ingin dijalankan. Ada beberapa cara lain untuk mendifinisikan function yang terdiri dari beberapa kumpulan command. Dibawah ini adalah daftar urut yang mana shell akan menge-check command yang dipakai;

* **Aliases**
Kumpulan nama dari perintah alias yang merepresentasikan beberapa perintah dan opsi-opsinya. Seringkali aliases digunakan untuk membuat shortcut untuk command dan opsi-opsinya yang panjang. Untuk melihat daftar aliases gunakan command *alias*.
```{.shell .no-copy}
maruffarras@BrownTofu:/usr/sbin$ alias

# Output
alias android='./IDE/android-studio/bin/studio.sh'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias intellij='/opt/idea-IC-212.5457.46/bin/idea.sh'
alias l='ls -CF'
alias la='ls -A'
alias laravel='~/./.config/composer/vendor/bin/laravel '
alias ll='ls -alF'
alias ls='ls --color=auto'
alias pycharm='./IDE/pycharm\ IDE/bin/pycharm.sh'
```

* **Shell reserved word**
Command tersebut tersimpan didalam shell. Banyak dari perintah ini kita gunakan dalam bahasa pemprogramman, seperti `do`, `while`, `case` dan `else`

* **Function**, Ini adalah kumpulan dari command yang dieksekusi bersamaan didalam current shell.

* **Builtin-command**, command ini adalah command bawaan yang tertanam didalam shell, seperti `cd` (change directory), `echo` (untuk menampilkan text pada layar), `exit`(untuk keluar dari shell), `fg`(untuk mengembalikan command yang berjalan pada background), `history`(untuk menampilkan riwayat command yang pernah dijalankan), `pwd`(menampilkan direktori yang sedang bekerja), `set` (untuk menyetel opsi dari shell) dan `type` (menampilkan lokasi dari command).
``` {.shell .no-copy} 
maruffarras@BrownTofu:~$ type python3
python3 is /usr/bin/python3

maruffarras@BrownTofu:~$ echo "Bismillah"
Bismillah

maruffarras@BrownTofu:~$ pwd
/home/maruffarras
```

* **Filesystem** command, command ini tertanam dan dijalankan dari pada filesystem


Untuk menampilkan lokasi dari sebuah command tertentu anda dapat menggunakan command `type`, namun jika anda menggunakan shell selain bash, anda dapat menggunakan command `which`. contohnya

``` {.shell .no-copy} 
maruffarras@BrownTofu:~$ type python3
python3 is /usr/bin/python3

maruffarras@BrownTofu:~$ which -a python3
/usr/bin/python3
/bin/python3
```

JIka sebuah command terdapat dibeberapa lokasi dan anda ingin mengetahui semua lokasinya, gunakan opsi `-a` pada command `type`

``` {.shell .no-copy} 
maruffarras@BrownTofu:~$ type -a python3
python3 is /usr/bin/python3
python3 is /bin/python3
```


Jika command tidak berada pada direkotori yang terdaftar pada variabel $PATH, anda dapat menggunakan command `locate` untuk mencarinya. Dengan `locate` anda dapat mencari 	bagian dari system namun dengan syarat anda memliki hak akses. Karena ada beberapa file yang hanya bisa diakses menggunakan root user.

``` {.shell .no-copy} 
maruffarras@BrownTofu:~$ locate python3
...
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_repr.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_set_literal.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_standarderror.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_sys_exc.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_throw.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_tuple_params.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_types.py
/snap/gnome-3-38-2004/115/usr/lib/python3.9/lib2to3/fixes/fix_unicode.py
...
```

JIka diperhatikan, command `locate` tidak hanya menemukan command python3, akan tetapi juga menemukan beberap file yang didalamnya mengandung command yang dicari. Command `locate` mencari diseluruh filesystem, tidak hanya pada direktori yang mengandung commands. 

!!! note
    Jika pada kasus tertentu perintah `locate` digunakan pada file yang baru saja ditambahkan pada system, bisajadi perintah tersebut tidak akan menemukannya pada filesystem. Untuk itu jalankan command `updatedb` sebagai user root untuk memperbarui locate database.

## Recalling Commands Using Command History
Dengan perintah `history`, anda dapat melihat daftar riwayat perintah yang pernah digunakan pada user anda. Serta anda juga dapat memangging kembali perintah tertentu dari daftar riwayat tersebut dan mengganti beberapa parameter pada perintah yang pernah digunakan sesuai yang dibutuhkan.

Selanjuta, pada sesi ini kita akan menjelaskan bagimana meng-edit command-line, bagaimana menyelesaikan bagian-bagian dari command-lines dan bagaimana memanggil kembali perinah yang ada pada daftar riwayat command line.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ history | tail
 2033  which python3
 2034  which -a python3
 2035  updatedb
 2036  sudo updatedb
```

### Command-line Editing
Jika anda salah mengetik beberapa perintah yang panjang pada terimanal, Bash shell memiliki fitur yang membuat anda tidak harus menghapus perintah panjang tersebut, melainkan hanya meng-edit-nya. Selain itu, anda juga dapat memanggil perintah yang pernah anda tulis dan mengganti elemen-elemen tertentu dan membuatnya menjadi perintah yang baru.

Bash shell (bawaanya) menggunakan command-line editing (text-editor) yang didasarkan pada **emacs** text editor. [More abouts emacs](https://www.gnu.org/software/emacs/)

#### Keystrokes for Navigating Command Lines
| Keystroke | Name | Fungsi |
| :-------- | :--- | :-------|
| ++ctrl++ + `F` | Character Forward | Go forward one character |
| ++ctrl++ + `B` | Character Backward | Go backward one character|
| ++alt++ + `F`| Word Forward |Go forward one word|
| ++alt++ + `B`| Word Backward |Go backward one word|
| ++ctrl++ + `A`| Beginning of Line| Go to the beginning of the current line|
| ++ctrl++ + `E`| End of Line|Go to the end of line|
| ++ctrl++ + `L`| Clear Screan|Clear the scren|

#### Keystrokes for Editing Command Lines
| Keystroke | Name | Fungsi |
| :-------- | :--- | :-------|
| ++ctrl++ + `D` | Delete current | Delete the current character |
| ++backspace++ | Delete previouse|Delete the previous character|
| ++ctrl++ + `T` | Transpose character | Switch positions of current and previous characters|
| ++alt++ + `T`| Transpose word |Switch positions of current and previous words|
| ++alt++ + `U`| Uppercase word |Change the current word to uppercase|
| ++alt++ + `L`| Lowercase word |Change the current word to lowercase|
| ++alt++ + `C`| Capitalize word |Change the current word to an initial capital|
| ++ctrl++ + `V`| Insert special character|Add a special character|


#### Keystrokes for Cutting and Pasting Text from within Command Lines

|Keystroke|Full Name|Meaning|
| :-------- | :--- | :-------|
|++ctrl++ + `K`|Cut end of line|Cut text to the end of the line|
|++ctrl++ + `U`|Cut beginning of line|Cut text to the beginning of the line|
|++ctrl++ + `W`|Cut previous word|Cut the word located behind the cursor|
|++alt++ + `D`|Cut next word|Cut the word following the cursor|
|++ctrl++ + `Y`|Paste recent text|Paste most recently cut text|
|++alt++ + `Y`|Paste earlier text|Rotate back to previously cut text and paste it|
|++ctrl++ + `C` |Delete whole line|Delete the entire line|


### Command-line completion
Bash shell memiliki fitur completion untuk memudahkan kita mengetik perintah. Misalkan adan ingin mengetik perintah yang panjang seperti python3, anda hanya perlu mengetik **py** lalu anda tekan ++tab++, maka shell akan menampilkan daftar perintah yang diawali dengan py jika ada beberapa perintah dengan awal tersebut, namun jika hanya satu perintah makan shell akan mengeluarkan pada command line satu perintah yang diawali dengan py.

Dibawahini adalah beberapa nilai yang dapat diketik sebagian dari bashshell:

`Command, alias atau function`
:   Jika kita menuliskan awalan karakter dengan karakter umum (_alfanumerik_) maka shell akan mencoba menampilkan kemungkinan command, alias atau nama fungsi dari sebagian karakter yang ditulis. Seperti diatas, ketika anda mengetik **py** pada terminal lalu menekan ++tab++, shell akan memberikan sugesti perintah atau alias atau nama yang diawali dengan huruf **py**,

`Variable`
:   Jika menuliskan text diawal dengan tanda dolar **$**, {==shell akan memberikan sugesti nama variable==}. Misalkan anda mengetik `$P` lalu menekan ++tab++, shell akan memberikan sugesti nama varriable dimana salah satunya adalah variable `#!shell $PATH`.
    ``` {.shell}
    maruffarras@BrownTofu:~$ $P # (1)!
    $PATH        $PPID        $PS2         $PWD         
    $PIPESTATUS  $PS1         $PS4 
    ```

    1.  Mengetik $P + ++tab++

`Username`
:   Dengan awalan **~**, shell akan memberikan sugesti username.
    ``` {.shell .no-copy}
    maruffarras@BrownTofu:~$ ~m # (1)!
    ~mail/        ~man/         ~maruffarras/ ~messagebus   ~mysql     
    ```

    1.  Mengetik ~m + ++tab++

`Hostname`
:   Dengan awala **@**, shell akan memberikan sugesti daftar host yang ada pada file `/etc/hosts/`. Hasil dibawah isi dari file `etc/hosts`
    ```{.shell .no-copy}
    maruffarras@BrownTofu:~$ cat /etc/hosts
    127.0.0.1	localhost
    127.0.0.1	BrownTofuMe
    127.0.1.1	BrownTofu

    # The following lines are desirable for IPv6 capable hosts
    ::1     ip6-localhost ip6-loopback
    fe00::0 ip6-localnet
    ff00::0 ip6-mcastprefix
    ff02::1 ip6-allnodes
    ff02::2 ip6-allrouters
    ```

### Command-line recall
Setelah anda mengetik sebuah perintah pada terminal, command tersebut akan disimpan pada history list pada shell tersebut. Daftar riwayat perintah tersebut tersimpan hinggal shell tersebut dikeluarkan (exit). Setelah itu, riwayat perintah akan disimpan pada file yang dapat dipanggil kembali pada sesi shell lainya. Pemanggilan perintah dari riwayat tersebut dapat dirubah dan dijalankan kembali.

Untuk melihat daftar riwayat perinah gunakan perintah `#!shell history`.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ history
  996  which -a pip
  997  pip list
  998  conda activate
  999  pip list
```

Anda dapat menggunakan opsi $n$ dengan tipe angka setelah perintah `#!shell history` untuk memberitahu shell menampilkan $n$ baris kahir dari daftar riwayat perintah.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ history 5
 1992  cat /etc/hosts
 1993  echo $HOSTFILE
 1994  exit
 1995  history
 1996  history 5
```

Anda dapat memanggil riwayat command tersebut dengan tanda seri _exclamation point_ **!** diikut dengan angka $n$ yang menentukan nomor berapa perintah yang ingin dipanggil. Namung penggunakan tanda seru tersebut langsung menjalankan command tanpa kita bisa merubah command tersebut.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ !1992 # (1)!
cat /etc/hosts
127.0.0.1	localhost
127.0.0.1	BrownTofuMe
127.0.1.1	BrownTofu

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

1.  Menjalankan id 1992 pada daftar history yang berisikan perintah `#!shell cat /etc/hosts`. 


Untuk menjalankan perintah sebelumnya (_previous command_) gunakan `!!`.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ !! # (1)!
cat /etc/hosts
127.0.0.1	localhost
127.0.0.1	BrownTofuMe
127.0.1.1	BrownTofu

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

1.  Persis menajalankan perintah sebelumnya saat memanggil perintah riawaya 1992

Anda juga dapat menajalankan perintah dari history list dengan parameter mengandung string tertentu, dengan syntax `#shell !string_command!`

```{.shell .no-copy}
maruffarras@BrownTofu:~$ !?dat? #(1)!
date
Jum 24 Feb 2023 11:49:27  WIB
```

1.  Mermanggil perintah `#!shell date` pada percobaan ini.

Oke, contoh penggunaan `!12`, `!!`, dan `!?dat?` akan memanggil history command dan langsung menjalankan. Ada baikmya memanggil perintah dari history list dan tidak langsung menjalankannya, akan tetapi anda dapat mengeditnya atau hanya memastikan perintah yang dipanggil tersebut benar.

Untuk itu anda dapat menggunakan _keys_ atau beberapa kombinasi _keys_ dibawah ini.

|Key(s)|Function Name |Description|
| :-------- | :--- | :-------|
|Arrow keyts ++up++ or ++down++||Press the up and down arrow keys to step through each command line in your history list to arrive at the one you  ant. (++ctrl++ + `P` and ++ctrl++ + `N` do the same functions, respectively.)|
|++ctrl++ + `R`|Reverse incremental search|After you press these keys, you enter a search string to do a reverse  earch. As you type the string, a matching command line appears that you can run or edit.|
|++ctrl++ + `S`|Forward incremental search|This is the same as the preceding function but for forward search. {==(It may not work in all instances.)==}|
|++alt++ + `P`|Reserve search|After you press these keys, you enter a string to do a reverse search. Type a string and press Enter to see the most recent command line that includes that string.|
|++alt++ + `N`|Forward search | This is the same as the preceding function but for forward search. {==(It may not work in all instances.)==}|

Setelah sesion shell telah selesai, history list akan disimpan pada file `.bash_history` yang berlokasi pada home direktori.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ tail ~/.bash_history
cat /etc/hosts
@
cat /etc/hosts
vim /etc/hosts
sudo vim /etc/hosts
source /etc/hosts
cat /etc/hosts
echo $HOSTFILE

exit
```

## Connecting and Expanding Command
Salah satu hal yang mempermudah kita dalam menggunakan shell adalah kita dapat menggunakan keluaran nilai dari satu command untuk dijadikan sebagai argumen pada command yang lainnya. Itu menggunakan fitur tersebut shell menggunakan hal yang disebut dengan **metacharacter**, ialah karakter-karakter yang memliki arti khusus bagi shell khusus untuk menghubungkan command.

Karakter-karakter tersebut adalah

|Name|Character|
| :--- | :--- : |
| pipe character | `|`|
|ampersand | `&` |
|Semicolon | `;` |
| right and left parenthesis | `(` and `)`|
| less and greater than sign | `<` and `>` |

### Piping between command
Karakater pipe digunakan utnuk menghubungkan output dari satu command ke input command lainnya.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ cat /etc/passwd | sort | tail -n 3
uuidd:x:107:115::/run/uuidd:/usr/sbin/nologin
whoopsie:x:116:123::/nonexistent:/bin/false
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
```

Command diatas memilki tujuan sebagai berikut, barikan hasil ouput dari `#!shell cat` ke input `#!shell sort`, lalu hasil output tersebut menjadi input `#!shell tail`.

`#!shell cat` :material-arrow-right: `#!shell sort` :material-arrow-right: `#!shell tail`.

### Squential command
Anda juga dapat membuat sebuah command berurutan. Command akan dijalankan jika ada command sebelumnya sudah selesai dieksekusi.

Misalkan sayang ingin meng-check dua buah website dengan perintah `#!shell ping` dan menampilkan waktu sebelum memulai ping dan setelah selesainya.

```{.shell .no-copy}
date ; ping www.google -c 2 ; ping www.anakshalihbogor.sch.id -c 2 ; date
Jum 24 Feb 2023 03:45:19  WIB
ping: www.google: Name or service not known
PING anakshalihbogor.sch.id (162.159.134.42) 56(84) bytes of data.
64 bytes from 162.159.134.42 (162.159.134.42): icmp_seq=1 ttl=58 time=189 ms
64 bytes from 162.159.134.42 (162.159.134.42): icmp_seq=2 ttl=58 time=32.7 ms

--- anakshalihbogor.sch.id ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 32.720/111.055/189.391/78.335 ms
Jum 24 Feb 2023 03:45:21  WIB
```

### Background command
Bawaanya, command yang diketik dan djilankan berjalan di depan layar, _foreground_. Jika demikian, hingga proses command tersebut berjalan anda tidak dapat menggunakan terminal tersebut. Untuk tetap bisa menggunakan layar terminal tanpa harus membuka session baru anda dapat menggunakan metacharacter ampersand yang membuat shell menjalankan perintah dibalik layar.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ sudo nmap -sU www.anakshalihbogor.sch.id &
[1] 13978
maruffarras@BrownTofu:~$ Starting Nmap 7.80 ( https://nmap.org ) at 2023-02-24 15:55 WIB
```
Untuk mengembalikan proses yang berjalan di background kembali ke foreground gunakan perintah #!shell fg`

### Expanding command
Untuk memperluas perintah, disebut dalam unix dengan _expanding command_ gunakan syntax 
```{.shell .no-copy}
echo $(sudo docker inspect $(sudo docker ps -aq)) > "test.txt"
```

### Expanding arithmetic expression
Kita juga melakukan operasi arimetik expression dalam shell mengguakaan syntax `#!shell $[expression`]
```{.shell .no-copy}
maruffarras@BrownTofu:~$ ping -c $[4+1] www.google.com
PING forcesafesearch.google.com (216.239.38.120) 56(84) bytes of data.
64 bytes from any-in-2678.1e100.net (216.239.38.120): icmp_seq=1 ttl=116 time=44.7 ms
64 bytes from any-in-2678.1e100.net (216.239.38.120): icmp_seq=2 ttl=116 time=58.4 ms
64 bytes from any-in-2678.1e100.net (216.239.38.120): icmp_seq=3 ttl=116 time=42.3 ms
64 bytes from any-in-2678.1e100.net (216.239.38.120): icmp_seq=4 ttl=116 time=41.1 ms
64 bytes from any-in-2678.1e100.net (216.239.38.120): icmp_seq=5 ttl=116 time=140 ms

--- forcesafesearch.google.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4004ms
rtt min/avg/max/mdev = 41.144/65.366/140.272/37.955 ms
```

perintah diatas akan mengirimkan icmp sebanyak 5 kali, `#!shell $[4+1]`

### Expanding Variable
Nilai dari sebuah variable dapat digunakan didalam sebuah command. Panggil saja variable tersebut dan sisipkan pada parameter sebuah command.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ echo  "Java home location is here {$JAVA_HOME}"
Java home location is here {/opt/jdk-11}
```

## Using Shell Variable
Shell menyimpan informasi yang berguna bagi shell session pada tempat yang dimanakan **variable**. Contoh variable seperti yang sering digunakan seperti `#!shell $PATH` atau `#!shell $USER`.

Untuk melihat daftar shell anda dapaat menggunakan command `#!shell ser`

```{.shell .no-copy}
maruffarras@BrownTofu:~$ set | head #(1)!
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:histappend:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="11")
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="1" [2]="8" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
```

1.  Command `#!shell head` diatas hanya ingin menampilkan bagian paling atas saja


### Creating and using aliases
Menggunakan `aliases` kita dapat membuat singkatan dari command yang panjang. Untuk membuat sebuah alias, gunakan perintah `#!alias alias` diikut dengan nama dari alias dan command yang ingin dibuat singkatannya. Misalkan

```{.shell .no-copy}
maruffarras@BrownTofu:~$ alias testp='echo "this is test print"'
maruffarras@BrownTofu:~$ testp
this is test print
```

Untuk melihat daftar alias gunakan perintah `#!shell alias` tanpa diberikan flag apapun.
```{.shell .no-copy hl_lines=6}
alias laravel='~/./.config/composer/vendor/bin/laravel '
alias ll='ls -alF'
alias ls='ls --color=auto'
alias note-mkdocs='source '\''/home/maruffarras/Virtual Env Python/notes/bin/activate'\'''
alias pycharm='./IDE/pycharm\ s/bin/pycharm.sh'
alias testp='echo "this is test print"'
```

Dapat dilihat alias `testp` yang dibuat terdaftar pada hasil output diatas.

Untuk menghapus alias dari daftar alias gunakan perintah `#!shell unalias` diikut dengan nama alias.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ unalias testp
maruffarras@BrownTofu:~$ testp
Command 'testp' not found,
```
!!! warning
    Membuat sebuah alias menggunakan `#!shell alias` hanya akan ada didalam system shell sementara,artinya jika session shell tersebut berakhir maka alias tersebut akan hilang. Jika menginginkan alias permanane buat alias didalam _configuration file_.


## Creating Your Shell Environment
Anda dapat membuat sebuah environment yang mempermudah anda seperti membuat alias dari command panjang yang sering dipakai atau membuat shell variabel untuk menyimpan informasi yang sering dipakai. Dengan manambah setting pada _shell configuration files_, anda dapat menyimpan setting setiap anda membuka shell.

**Bash Configuration Shell**

|File |Descriptions |
| :---- | :------ |
|`/etc/profile` | This sets up user environment information for every user. It is executed when you first log in. This  file provides values for your path in addition to setting environment variables for such things as the location of  our mailbox and the size of your history files. Finally, `/etc/profile` gathers shell settings from configuration files in the /etc/ for every user who runs the Bash shell each time a Bash shell is opened. It sets the default prompt and may add one or more aliases. Values in this file can be overridden by information in each user’s `~/.bashrc file`.|
|`/etc/bash.bashrc`|This executes for every user who runs the Bash shell each time a Bash shell is opened. It sets the default prompt and may add one or more aliases. Values in this file can be overridden by information in each user’s `~/.bashrc` file.|
|`~/.profile`|This is used by each user to enter information that is specific to his or her use of the shell. It is executed only once—when the user logs in. By default, it sets a few environment variables and executes the user’s .bashrc file. This is a good place to add environment variables because, once set, they are inherited by future shells. This file will be overruled if a `~/.bash` _ profile file exists.|
|`~/.bashrcs`|This contains the information that is specific to your Bash shells. It is read when you log in and also each time you open a new Bash shell. This is the best location to add aliases so that your shell picks them up.|
|`~/.bash_logout`|This executes each time you log out (exit the last Bash shell).|


Untuk merubah file konfigurasi `/etc/bash.bashrc` atau `/etc/profile` harus menggunakan root user. Akan tetapi sangat disarankan untuk tidak membuat konfigurasi langsung pada kedua file tersebut namun buatlah sebuah file ekstensie **sh** dan diletakan pada alamat `/etc/profile.d/`. Anda dapat melihat kode dibawah ini bagaimana semua file sh pada `/etc/prfile.d` dieksekusi.

```{.shell .no-copy hl_lines="20-27" title="/etc/profile"}
# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))
# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).

if [ "${PS1-}" ]; then
  if [ "${BASH-}" ] && [ "$BASH" != "/bin/sh" ]; then
    # The file bash.bashrc already sets the default PS1.
    # PS1='\h:\w\$ '
    if [ -f /etc/bash.bashrc ]; then
      . /etc/bash.bashrc
    fi
  else
    if [ "$(id -u)" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi
  fi
fi

if [ -d /etc/profile.d ]; then
  for i in /etc/profile.d/*.sh; do
    if [ -r $i ]; then
      . $i
    fi
  done
  unset i
fi
```

!!! info
    yang perlu diingat`/etc/profile` dieksekusi saat system start, bukan saat login atau shell membuat shell baru.


### Setting your prompt
Prompt anda terdiri dari beberapa kumpulan karakter yang muncul setiap kali shell siap untuk menerima perintah. Kumpulkan karakter pada environment variable `#!shell PS1` adalah yang digunakan pada prompt anda.

Bawaanya pada system Ubunut, prompt yang dibentuk dari karakter-karakter memberikan informasi, seperti _username_, _hostname_, dan _base name of current working directory_ lalu diikuti dengan tanda dolar `$` yang menunjukan reguler user dan `#` yang menunjukan root user.

```{.shell .no-copy}
maruffarras@BrownTofu:~$ #(1)!
```

1.  _username_@_hostname_:~$

Jika anda menggatin direktori, maka basename dari current direktori akan tampil pada prompt.

```{.shell .no-copy}
maruffarras@BrownTofu:~/Documents$ 
```

Ada juga dapat membuat costume prompt sendiri dengan meng-export environment variabel `#!shell PS1`. Jika ingin merubahnya secara permanen export variabel tersebut pada file `~/.bashrc`. Namun perlu diingat export variable tersebut harus diletakan dibawah dari penetapan `#!shell PS1` bawaan dari ubuntu.

```{ .shell .no-copy title="~/.bashrc"}
if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# costume prompt
export PS1='\u@\h'#(1)!

# Output (2)
```

1.  Letakan tempat dibawah inisiasi `PS1` bawaan dari Ubuntu
2.  Jika anda membuka shell baru maka prompt akan ditiban menjadi `maruffarras@BrownTofu`


Dibawah ini adalah contoh pembuatan costume propt sementara, (tidak menulis didalam .bashrc) informasi prompt yang saya buat adalah sebagai berikut, 

:   _nomor urut_ **.** _Current Date_-_username_ **@** _hostname_ **:** _userprompt_ _display full path current direktory_

```{.shell .no-copy}
maruffarras@BrownTofu:~$ export PS1='\#.\d-\u@\h:\$\w'
2.Jum Mar 03-maruffarras@BrownTofu:$~pwd
/home/maruffarras
3.Jum Mar 03-maruffarras@BrownTofu:$~
```
Dan dibawah ini adalah daftar karakter yang dapat menambah informasi pada prompt

|Special Character|Description|
|:----:|:---------------------|
|`\!`| Menampilkan current history number. Termasuk semua perintah sebelumnya dari user anda |
|`\#`| Menampilkan curretn history number. Hanya termasuk perintah dari shell yang aktif |
|`\$`| Menampilkan user prompt `$` dan `#` untuk root user |
|`\W`| Hanya menampilkan direktori saat ini, namun hanya basename saja. Contoh, misalkan alamatnya adalah `/opt/other/agent` maka hanya akan ditampilkan `agent` |
|`\[`|This precedes a sequence of nonprinting characters. This can be used to add a terminal control sequence into the prompt for such things as changing colors, adding blink effects, or making characters bold. (Your terminal determines the exact sequences available.) |
|`\]`|This follows a sequence of nonprinting characters. |
|`\\`| Menampilkan backslash `\` |
|`\d`| Menampilkan tanggal saat ini, `Jum Mar 03`. Format mengikuti system |
|`\h`| Menampilkan hostname komputer tersebut |
|`\n`| Membuat baris baru |
|`\nnn`| Menambilkan bilangan yang berhubungan dengan ocatal number dengan menggati `nnn` |
|`\s`| Menampilkan shell name saat ini, untuk Bash shell akan menjadi `bash` |
|`\t`| Menampilkan waktu jam, menit dan detik saat ini, contoh, `09:04:23` |
|`\u`| Menampilkan current username |
|`\w`| Menampilkan alamat lengkap dari direktori saat ini |


### Adding environment variables
Kita telah mencoba mengedit environment variable saat membuat [costume prompt](#setting-your-prompt) pada file `~/.bashrc`. Dibawah ini contoh saya membuat environment variable untuk membuat JAVA_HOME.
```{.shell .no-copy title="~/.bashrc"}
export JAVA_HOME=/opt/jdk-11
```

```{.shell .no-copy}
maruffarras@BrownTofu:~$ echo $JAVA_HOME
/opt/jdk-11
```

## Getting information about command
Sudah ada catatan pada [location command](#locating-commands) bagaimana shell mencari command yang diketik dari alamat yang ada pada environment variabel `$PATH` dengan urutan dari kiri → kanan. Katakan kita ingin melihat daftar command yang ada pada folder bin

```{.shell .no-copy}
maruffarras@BrownTofu:~$ echo $PATH
/home/maruffarras/anaconda3/condabin:/home/maruffarras/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/
sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/opt/jdk-11/bin:/opt/kafka/kafka_2.13-3.4.0/bin

maruffarras@BrownTofu:~$ ls /bin
 gtk4-encode-symbolic-svg             pygmentize
 2to3-2.7                             gtk4-launch                        pyjwt3
 aa-enabled                           gtk4-query-settings                python2.7
 aa-exec                              gtk4-update-icon-cache             python3
 aa-features-abi                      gtk-builder-tool                   python3.9

```

*   Menggunakan perintah `help`
: Beberapa perintah tidak ada didalam direktori, artinya tertanam didalam shell. Perintah `help` menampilkan daftar command yang tertanam. Dan untuk mengetahui deskripsi dari perintaht tersebut anda dapat menambahkan nama perintahnya setalah perintah `help`
    ```{.shell .no-copy}
    maruffarras@BrownTofu:~$ help cd
    ```  

* Menggunakan option `--help`
:   Anda juga dapat menggunakna opsi `--help` untuk mengetahui informasi dari sebuah perintah. Biasanya didalam manual tersebut terdapat parameter dari perintah tersebut yang bisa diisi dengan argumen dan penjelsan dari setiap paramter tersebut.

* Menggunakan perintah `man` atau `info`
:   Adalah tool yang dapat digunakan untuk melihat dokumentasi dari sebuah perintah. Biasanya, sebuah informasi dari perintah yang ada pada perintah `info` selalu lebih ada dibandingkan dengan yang ada pada perintah `man`.

Perintah `man` memliki beberapa section, jika section tersebut disediakan dalam bentuk parameter maka `man` akan menuju langsung ke section tersebut. Bawaanya, jika tidak diberikan parameter section, man akan mencari dari seluruh section yang diberikan lalu mengembalikan halaman pertama yang ditemukan. Tabel dibawah ini adalah daftar section dari `man`.

| Section number | Section name | Description |
| :------------: | :----------- | :---------- |
| 1 | Executable programs or shell commands| Command yang dapat dijalankan di shell oleh user umum (Biasanya tidak perlu akses administrative)|
| 2 | System calls | Programming function yang digunakan didalam sebuah aplikasi untuk berinteraksi (memanggil) dengan kernel|
| 3 | Library calss (C Library function) | Programming function yang menyediakan interface untuk pustaka programming tertentu (seperti graphical interface) |
| 4 | Device and Special files|Filesystem nodes that represent hardware devices (such as terminals or CD drives) or software devices (such as random number generators) |
| 5 | File formats and Conventions | Types of files (such as a graphics or word processing file) or specific configuration files (such as the passwd or group file) |
| 6 | Games | Games available on the system|
| 7 | Miscellanous| Overviews of topics such as protocols, filesystems, character set standards, and so on |
| 8 | System Administration Tools and Daemons | Commands that require root or other administrative privileges to use |

Perintah `man` memliki parameter `-k` yang berguna untuk mencari manual page yang mirip dengan parameter yang diberikan setelah flag `-k`. Katakan kita ingin melihat semua manual page yg tersedia dari perintah `passwd`.

!!! quote "Deskripsi flag `-k`"
    you can search the name and summary sections of all man pages installed on the system

```{.shell .no-copy}
maruffarras@BrownTofu:~$ man -k passwd
kpasswd (1)          - change a user's Kerberos password
chgpasswd (8)        - update group passwords in batch mode
chpasswd (8)         - update passwords in batch mode
fgetpwent_r (3)      - get passwd file entry reentrantly
getpwent_r (3)       - get passwd file entry reentrantly
gpasswd (1)          - administer /etc/group and /etc/gshadow
grub-mkpasswd-pbkdf2 (1) - generate hashed password for GRUB
htpasswd (1)         - Manage user files for basic authentication
openssl-passwd (1ssl) - compute password hashes
pam_localuser (8)    - require users to be listed in /etc/passwd
passwd (1)           - change user password
passwd (1ssl)        - compute password hashes
passwd (5)           - the password file
passwd2des (3)       - RFS password encryption
update-passwd (8)    - safely update /etc/passwd, /etc/shadow and /etc/group
```

Angka yang ada didalam tanda kurung mengidikasi section dari manual page pada tabel diatas. Katakan kita ingin melihat file format dari perintah `passwd` dari pada inging melihat manual dari perintah shell commandnya. Untuk itu gunakan contoh berikut `man 5 passwd`

Saat anda menampilkan halama man page, anda dapat mencari text tertentu dengan mengetik _forward slahs_ `/` diikuti dengan informasi yang ingin dicari. Anda juga dapat mencari previous atau next nilai yang dicari dengan menekan `N` for previous atau `n` for next. Untuk keluar dari manual page gunakan `q`.


!!! note
    Jika `#!shell man -k` tidak mengeluar nilai sama sekali, bisa jadi database pada man page belum terinisiasi. Untuk itu ketik `#!shell mandb` sebagai root user untuk menginisialisasi man page databases.


## Exercise
??? question "Pertanyaan 1"
    From your desktop, switch to the third virtual console and log in to your user account. Run a few commands. Then exit the shell and return to the desktop.

    ??? info "Jawaban"
        Gunakan shortcut ++ctrl++ + ++alt++ + `f2`, atau ++ctrl++ + ++alt++ + `f3` dan atau ++ctrl++ + ++alt++ + `f4`. Baca lebih lanjut di [menggunakan virtual console](#menggunakan-virtual-console)

??? question "Pertanyaan 2"
    Open a Terminal window and change the font color to red and the background to yellow.

    ??? info "Jawaban"
        ![jawab](aset/1.1%20change_font_and_color_terminal.png)

??? question "Pertanyaan 3"
    Find the location of the `#!shell mount` command and the `#!shell tracepath` man page.
    
    ??? info "Jawaban"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ which -a mount
        /usr/bin/mount
        /bin/mount
        maruffarras@BrownTofu:~$ which -a tracepath
        /usr/bin/tracepath
        /bin/tracepath
        ```

        Baca lebih lanjut mengenail command `locate` dan `which -a` di [Locating Command](#locating-commands)

??? question "Pertanyaan 4"
    Type the following three commands, and then recall and change those command as described:
    ```{.shell .no-copy}
    $ cat /etc/passwd
    $ ls $HOME
    $ date
    ```

    1.   Use the command-line recall feature to recall the cat command and change /etc/passwd to /etc/group.
    2.   Recall the ls command, determine how to list files by time (using the man page), and add that option to the ls $HOME command line.
    3.   Add format indicators to the date command to display the date output as month/day/year.

    ??? info "Jawaban 1"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ cat /etc/group #(1)!
        root:x:0:
        daemon:x:1:
        bin:x:2:
        sys:x:3:
        ```

        1.  Pencet ++up++ hingga muncul command yang dibutuhkan, lalu rubah command sesuai dengan perintah. Atau anda gunakan reverse search dengan menggunakan ++ctrl++ + `r` lalu ketik beberapa kata perintah.

        Baca lagi tentang [command-line recall](#command-line-recall)

    ??? info "Jawaban 2"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ ls -tlar $HOME
        total 15280
        -rw-rw-r--  1 maruffarras maruffarras   57721 Sep 30  2021  composer-setup.php
        -rw-r--r--  1 maruffarras maruffarras     807 Des 30  2021  .profile
        -rw-r--r--  1 maruffarras maruffarras     220 Des 30  2021  .bash_logout
        drwxr-xr-x  3 maruffarras maruffarras    4096 Des 30  2021 'Development Apps'
        drwxr-xr-x  3 maruffarras maruffarras    4096 Des 30  2021  etcher
        drwxr-xr-x  2 maruffarras maruffarras    4096 Des 30  2021  kotlin
        ```

    ??? info "Jawaban 3"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ date +%D
        03/03/23
        ```



??? question "Pertanyaan 5"
    Run the following command, typing as few characters as possible (using tab completion):
    `#!shell basename /usr/share/doc/`

    **Tidak ada output**

??? question "Pertanyaan 6"
    Use the cat command to list the contents of the /etc/services file and pipe those contents to the less command so that you can page through it (type q to quit when you are finished).
    
    ??? info "Jawaban"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ cat /etc/services | less
        ```

    Baca lagi tentang [piping command](#piping-between-command)


??? question "Pertanyaan 7"
    Run the `#!shell date` command in such a way that the output from that command produces the current day, month, date, and year. Have that read into another command line, resulting in text that appears like the following (your date, of course, will be different): Today is Thursday, December 19, 2019.

    ??? info "Jawaban"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ echo "Today is $(date)"
        Today is Jum 03 Mar 2023 11:31:29  WIB
        ```

    Baca lagi tentang [expanding command](#expanding-command)

??? question "Pertanyaan 8"
    Using variables, find out what your hostname, username, shell, and home directories are currently set to.

    ??? info "Jawaban"
        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ echo $HOSTNAME
        BrownTofu
        maruffarras@BrownTofu:~$ echo $USERNAME
        maruffarras
        maruffarras@BrownTofu:~$ echo $SHELL
        /bin/bash
        maruffarras@BrownTofu:~$ echo $HOME
        /home/maruffarras
        ```
    
    Baca lagi tentang [creating and using aliases](#creating-and-using-aliases)

??? question "Pertanyaan 9"
    Create an alias called mypass that displays the contents of the `/etc/passwd` file on your screen in such a way that it is available every time you log in or open a new shell from your user account.

    ??? info "Jawaban"
        Agar `alias` selalu dapat diakses walaupun session shell sudah habis atau login baru maka buat alias didalam file `~/.bashrc` alih-alih  membuat langsung pada shell.
        
        ```{.shell .no-copy title="~/.bashrc"}
        alias mypass='cat /etc/passwd'
        ```

??? question "Pertanyaan 10"
    Display the man page for the `#!shell mount` system call.

    ??? info "Jawaban"
        `mount (2) - mount filesystem`

        ```{.shell .no-copy}
        maruffarras@BrownTofu:~$ man mount
        ```

---
Alhamdulillah segala puji bagi Allah, tuhan satu-satunya yang berhak disembah dengan benar. Semoga bagian catatan ini bermanfaat bagi diri saya, Aamiin.